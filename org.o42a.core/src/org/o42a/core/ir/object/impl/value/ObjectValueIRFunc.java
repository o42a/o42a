/*
    Compiler Core
    Copyright (C) 2010,2011 Ruslan Lopatin

    This file is part of o42a.

    o42a is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    o42a is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
package org.o42a.core.ir.object.impl.value;

import org.o42a.codegen.CodeId;
import org.o42a.codegen.code.Func;
import org.o42a.codegen.code.FuncPtr;
import org.o42a.codegen.code.Function;
import org.o42a.codegen.data.FuncRec;
import org.o42a.core.artifact.object.Obj;
import org.o42a.core.artifact.object.ObjectType;
import org.o42a.core.def.SourceInfo;
import org.o42a.core.ir.object.*;
import org.o42a.core.ir.object.impl.ObjectIRFunc;


public abstract class ObjectValueIRFunc<F extends Func<F>>
		extends ObjectIRFunc {

	private final ObjectValueIR valueIR;
	private final CodeId id;
	private FuncPtr<F> funcPtr;
	private FuncRec<F> func;
	private boolean reused;

	ObjectValueIRFunc(ObjectValueIR valueIR) {
		super(valueIR.getObjectIR());
		this.valueIR = valueIR;
		this.id = getObjectIR().getId().setLocal(
				getGenerator().id().detail(suffix()));
	}

	public final ObjectValueIR getValueIR() {
		return this.valueIR;
	}

	public final CodeId getId() {
		return this.id;
	}

	public final boolean isReused() {
		return this.reused;
	}

	public final FuncPtr<F> get() {
		if (this.funcPtr == null) {
			create();
		}
		return this.funcPtr;
	}

	public void allocate(ObjectTypeIR typeIR) {
		this.func = func(typeIR.getObjectData());
		this.func.setValue(get());
	}

	public final FuncPtr<F> get(ObjOp host) {

		final ObjectIR objectIR = host.getAscendant().ir(getGenerator());
		final ObjectTypeIR typeIR =
			objectIR.getBodyType().getObjectIR().getTypeIR();
		final ObjectIRData data = typeIR.getObjectData();

		return func(data).getValue();
	}

	public int addSources(SourceInfo[] destination, SourceInfo[] sources) {

		int size = 0;

		for (SourceInfo def : sources) {
			size = addSource(destination, size, def);
		}

		return size;
	}

	protected abstract void create();

	private int addSource(SourceInfo[] destination, int at, SourceInfo source) {

		final Obj src = source.getSource();

		if (src == getObjectIR().getObject()) {
			// explicit definition - add unconditionally
			destination[at] = source;
			return at + 1;
		}

		final ObjectType srcType = src.type();

		for (int i = 0; i < at; ++i) {

			final SourceInfo dest = destination[i];

			if (dest == null) {
				continue;
			}

			final ObjectType destType = dest.getSource().type();

			if (destType.derivedFrom(srcType)) {
				// definition will be generated by derived definition
				return at;
			}
			if (destType.derivedFrom(srcType)) {
				// new definition generates ascending one
				destination[i] = null;
			}
		}

		destination[at] = source;

		return at + 1;
	}

	@Override
	public String toString() {
		return getId().toString();
	}

	protected abstract String suffix();

	protected final void set(Function<F> function) {
		this.funcPtr = function.getPointer();
		this.reused = false;
	}

	protected final void reuse(FuncPtr<F> ptr) {
		this.funcPtr = ptr;
		this.reused = true;
	}

	protected abstract FuncRec<F> func(ObjectIRData data);

}
